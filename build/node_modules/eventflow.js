// YellowLeaf FTP by Michiel Dral 

/*
EventEmitter that waits for all events to return (a value)
This works when you want events to alter the same result, without interferring.
 */
var EventFlow, EventFlowEvent, EventFlowKilledError, Q, async,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

async = require('async');

Q = require('kew');

require('dralpolyfills');

EventFlow = (function() {
  function EventFlow() {}

  EventFlow.prototype.at = function(event, fn, priority) {
    if (priority == null) {
      priority = 0;
    }
    this.__ensureProperties(event);
    fn.priority = priority;
    this.eventFlowEvents[event].push(fn);
    this.eventFlowEvents.sorted = false;
    return true;
  };

  EventFlow.prototype.fire = function(event, properties) {
    var eventFlowEvent;
    this.__ensureProperties(event);
    if (!this.eventFlowEvents[event].sorted) {
      this.eventFlowEvents[event] = this.eventFlowEvents[event].sort(function(a, b) {
        return b.priority - a.priority;
      });
      this.eventFlowEvents[event].sorted = true;
    }
    eventFlowEvent = new EventFlowEvent(event, properties);
    return async.eachSeries.asPromise(this.eventFlowEvents[event], (function(_this) {
      return function(fn, next) {
        if (eventFlowEvent.killed) {
          throw new EventFlowKilledError;
        }
        eventFlowEvent.next = next;
        return fn.call(_this, eventFlowEvent);
      };
    })(this)).then(function(err) {
      if (err && err.__proto__ !== EventFlowKilledError.prototype) {
        throw err;
      }
      return eventFlowEvent;
    });
  };

  EventFlow.prototype.__ensureProperties = function(event) {
    if (this.eventFlowEvents == null) {
      this.eventFlowEvents = {};
    }
    if (this.eventFlowEvents[event] == null) {
      return this.eventFlowEvents[event] = [];
    }
  };

  return EventFlow;

})();

EventFlowKilledError = (function(_super) {
  __extends(EventFlowKilledError, _super);

  function EventFlowKilledError() {
    return EventFlowKilledError.__super__.constructor.apply(this, arguments);
  }

  EventFlowKilledError.prototype.name = 'EventKilledError';

  EventFlowKilledError.prototype.message = 'Event is killed, hahahahaha';

  return EventFlowKilledError;

})(Error);

EventFlowEvent = (function() {
  function EventFlowEvent(name, defaults) {
    defaults.forEach((function(_this) {
      return function(value, key) {
        return _this[key] = value;
      };
    })(this));
    this.canceled = false;
    this.killed = false;
    this.name = name;
    this.next = function() {
      throw new Error("No next-callback defined!");
    };
  }

  EventFlowEvent.prototype.cancel = function(really) {
    if (really == null) {
      really = true;
    }
    return this.canceled = really;
  };

  EventFlowEvent.prototype.kill = function(reallyreallyreally) {
    if (reallyreallyreally == null) {
      reallyreallyreally = YES;
    }
    return this.killed = reallyreallyreally;
  };

  return EventFlowEvent;

})();

module.exports = EventFlow;

###
EventEmitter that waits for all events to return (a value)
This works when you want events to alter the same result, without interferring.
###

async = require 'async'
Q = require 'kew'
require 'dralpolyfills'

class EventFlow
    at: (event, fn, priority=0) ->
        @__ensureProperties event
        
        fn.priority = priority
        @eventFlowEvents[event].push(fn)
        @eventFlowEvents.sorted = false
        true
        
    fire: (event, properties) ->
        @__ensureProperties event
        
        if not @eventFlowEvents[event].sorted
            @eventFlowEvents[event] = @eventFlowEvents[event].sort (a, b) ->
                b.priority - a.priority
            @eventFlowEvents[event].sorted = true
        
        eventFlowEvent = new EventFlowEvent(event, properties)
        async.eachSeries.asPromise @eventFlowEvents[event], (fn, next) =>
            if eventFlowEvent.killed
                throw new EventFlowKilledError
            
            eventFlowEvent.next = next
            fn.call this, eventFlowEvent
        .then (err) ->
            if err and err.__proto__ isnt EventFlowKilledError.prototype
                throw err
            eventFlowEvent
            
    __ensureProperties: (event) ->
        if not @eventFlowEvents?
            @eventFlowEvents = {}
        if not @eventFlowEvents[event]?
            @eventFlowEvents[event] = []

class EventFlowKilledError extends Error
    name: 'EventKilledError'
    message: 'Event is killed, hahahahaha'

class EventFlowEvent
    constructor: (name, defaults) ->
        defaults.forEach (value, key) =>
            this[key] = value
            
        this.canceled = false
        this.killed = false
        this.name = name
        this.next = ->
            throw new Error "No next-callback defined!"
    cancel: (really=yes) ->
        this.canceled = really
    kill: (reallyreallyreally=YES) ->
        this.killed = reallyreallyreally

module.exports = EventFlow

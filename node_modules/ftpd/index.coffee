net = require "net"
path = require "path"
fs = require 'fs'
Q = require 'kew'

EventEmitter = require("events").EventEmitter
SuperClass = require "superclass"

FtpDataPool = require './ftpdatapool'

EventEmitter::emitWith = (event, scope, args...) ->
    @listeners(event).forEach (fn) ->
        fn.apply(scope, args)

class FtpServer extends EventEmitter
    constructor: (connectionListener) ->
        connectionListener = if typeof connectionListener is "function" then connectionListener else () ->
    
        @server = net.createServer (socket) =>
          @emitWith 'connection', new FtpClient(socket)
        
        @on 'connection', connectionListener
        SuperClass.inherit(this, ['address', 'listen'], @server)


class FtpClient extends EventEmitter
    constructor: (connection) ->
        @host = connection.localAddress
        @_connection = connection
        @cwd = '/'
        @basedir = process.cwd()
        @dataServer = new FtpDataPool(this)
        
        @_connection.on 'readable', () =>
            data = @read()
            if not data then return
            [cmd, args...] = data.split(' ')
            cmd = cmd.toLowerCase()
            
            options = []
            args = args.filter (arg) ->
              if arg.indexOf('-') is 0
                options.push args
                false
              else
                true
            cmd.options = options
              
            console.log "Command: #{cmd} with #{args}"
              
            if @listeners('command.' + cmd).length < 1
                @emit 'unknownCommand', cmd, args.join ' '
                
            @emit.call this, 'command.' + cmd, args.join ' '
            
        @write '220 Welcome!'
        
        
    getFullPath: (file='') ->
        if not @cwd? then @cwd = '/'
        if not @basedir? then @basedir = '/'
        if not file.startsWith '/'
          file = path.join @cwd, file
        path.join @basedir, file
        
        
    fs: (method, file, args...) ->
        defered = Q['defer']()
        currpath = @getFullPath file
        fs[method] currpath, args..., defered.makeNodeResolver()
        
        defered.promise.fail (err) =>
          @write "550 Can't fly here, this place does not exist"
          err.ftpNotified = true
          throw err
        
    write: (data) ->
        @_connection.write(data + '\r\n')
        
    read: (size) ->
        data = @_connection.read(size)
        return if not data
        data.toString().trim()
        
    end: () ->
        @_connection.end()
        @dataServer = undefined

            
module.exports = FtpServer
module.exports.FtpClient = FtpClient
module.exports.FtpDataPool = FtpDataPool

module.exports.defaults =
  dataSocket: () ->
    @on 'command.pasv', () ->
      @dataServer.openPasv()
    @on 'command.port', (args) ->
      @dataServer.openPort(args)
  
  unknownCommand: () ->
    @on 'unknownCommand', (cmd, args) ->
      console.log "Command #{cmd} not implemented (args: #{args})."
      return @write '500 Sorry.'
        

# If not included, run yourself
if not module.parent
    ftpserver = new module.exports
    ftpserver.listen(800)
    
    

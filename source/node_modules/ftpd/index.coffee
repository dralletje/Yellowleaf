net = require "net"
path = require "path"

Promise = require 'bluebird'
fs = Promise.promisifyAll require("fs")

EventEmitter = require("events").EventEmitter
SuperClass = require "superclass"
debug = require('debug')('[FTP]', 'cyan')

FtpDataPool = require './ftpdatapool'

EventEmitter::emitWith = (event, scope, args...) ->
    @listeners(event).forEach (fn) ->
        fn.apply(scope, args)

class FtpServer extends EventEmitter
  constructor: (connectionListener) ->
    connectionListener = if typeof connectionListener is "function" then connectionListener else () ->

    @server = net.createServer (socket) =>
      @emitWith 'connection', new FtpClient(socket)

    @on 'connection', connectionListener

    # Inherit methods/props with value
    ['address'].forEach (method) =>
      @[method] = @server[method]

  # Inherit methods that should return `this`
  ['listen', 'close'].forEach (method) =>
    @::[method] = (args...) ->
      @server[method] args...
      this

  debug: (pleasedo) ->
    if pleasedo
      debug = require('debug')('[FTP]', 'cyan')
    else
      debug = ->


class FtpClient extends EventEmitter
    constructor: (connection) ->
        @host = connection.localAddress
        @_connection = connection
        @cwd = '/'
        @basedir = process.cwd()
        @dataServer = new FtpDataPool(this)

        @_connection.on 'readable', () =>
            data = @read()
            if not data then return
            [cmd, args...] = data.split(' ')
            cmd = cmd.toLowerCase()

            options = []
            args = args.filter (arg) ->
              if arg.indexOf('-') is 0
                options.push args
                false
              else
                true
            cmd.options = options

            debug "Command: #{cmd} with #{args}"

            if @listeners('command.' + cmd).length < 1
                @emit 'unknownCommand', cmd, args.join ' '

            @emit.call this, 'command.' + cmd, args.join ' '

        @write '220 Welcome!'


    getFullPath: (file='') ->
        if not @cwd? then @cwd = '/'
        if not @basedir? then @basedir = '/'
        if not file.startsWith '/'
          file = path.join @cwd, file
        path.join @basedir, file


    ###
    fs: (method, file, args...) ->
      currpath = @getFullPath file
      fs[method + "Async"](currpath, args...)
      .catch (err) =>
        @write "550 Can't fly here, this place does not exist!"
        err.ftpNotified = true
        throw err
    ###

    write: (data) ->
        @_connection.write(data + '\r\n')

    read: (size) ->
        data = @_connection.read(size)
        return if not data
        data.toString().trim()

    end: () ->
        @_connection.end()
        @dataServer = undefined


module.exports = FtpServer
module.exports.FtpClient = FtpClient
module.exports.FtpDataPool = FtpDataPool

module.exports.defaults =
  dataSocket: () ->
    @on 'command.pasv', () ->
      @dataServer.openPasv()
    @on 'command.port', (args) ->
      @dataServer.openPort(args)

  unknownCommand: () ->
    @on 'unknownCommand', (cmd, args) ->
      debug "Command #{cmd} not implemented (args: #{args})."
      return @write '500 Sorry.'


# If not included, run yourself
if not module.parent
    ftpserver = new FtpServer
    ftpserver.listen(800)
